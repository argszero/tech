
不同路径。
tags: javascript，算法， 动态规划, 矩阵，排列组合

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？

+-----+------+------+------+------+------+------+------+------+------+------+
|Start|      |      |      |      |      |      |      |      |      |      |
+-----+------+------+------+------+------+------+------+------+------+------+
|     |      |      |      |      |      |      |      |      |      |      |
+-----+------+------+------+------+------+------+------+------+------+------+
|     |      |      |      |      |      |      |      |      |      |      |
+-----+------+------+------+------+------+------+------+------+------+------+
|     |      |      |      |      |      |      |      |      |      |      |
+-----+------+------+------+------+------+------+------+------+------+------+
|     |      |      |      |      |      |      |      |      |      |Finish|
+-----+------+------+------+------+------+------+------+------+------+------+

因为机器人智能向下或者向右移动，所以对任意个一个单元格来说，进入这个单元格只有两种方法，一种是从上方进入，一种是从左边进入。
到达这个单元格的路径数 = 到达它上方单元格的路径数 + 到达它右边单元格到达路径数。
我们使用dp[i][j]代表到达第i行，第j列的单元格的路径数，那么
dp[i][j] = dp[i-1][j] + dp[i][j-1]
这个就是动态规划里的转移方程了。

初始状态：矩阵的第一行和第一列里每个单元格，显然只有一种进入方法, 即 if(i===0 || j===0) p[i][j]=1
根据这个转移方程，我们很容易写出代码实现：
```javascript
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    const pd=[];
    for(let i=0;i<m;i++){
        pd[i]=[];
        for(let j=0;j<n;j++){
            if(i===0||j===0)pd[i][j]=1
            else pd[i][j]=pd[i-1][j]+pd[i][j-1]
        }
    }
    return pd[m-1][n-1]
};
```

以上是程序员的解题思路，但是我正在上小学的儿子可不这么想，这道题如果在小学奥数题里出现，他会怎么解决呢？

首先，因为只能向左或者向下走，所以对于任意一个单元格，要到达这个单元格需要向下走多少步，向右走多少步都是固定的。
比如，对于第四行，第5列第单元格来说，肯定需要向下走3步，向右走4步。
另一方面，向左走或者向右走的顺序又是可以任意选择的，不管如何选择，只要向下走3步，向右走4步,就一定能到达第四行，第5列第单元格。

所以，到达第四行，第5列单元格,  其实总共要走3+4 =7 步，从这7步里任意选择3步向下走，或者任意选择4步向右走就可以了
记 C_7^3 = C_7^4 = 7*4*3/(3*2*1) = 14
对于本题来说，就是求第m-1行，第n-1列单元格的路径数： C_{m-1+n_1}^{m-1} =  C_{m-1+n_1}^{n-1} 
实现代码:

```javascript
function factorial(a,b){
    if(b===a)return a
    return a*factorial(a-1,b)
}

function combination(n, r) {
    if(r===0)return 1;
    return factorial(n,n-r+1) / factorial(r, 1);
}

/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    return combination(m-1+n-1,m-1)
};
```

